// ============================================================
// CODE NAME (Project Constitution compliant)
// ============================================================
// BASE: ENTRY_FRAMEWORK_M5_ALL_001_000_001_B
// THIS: ENTRY_FRAMEWORK_M5_ALL_001_004
// ARCHIVE_ID: 001_003 (dirfilter+news removed variant)
// ============================================================

using System;
using System.Collections.Generic;
using System.Globalization;
using cAlgo.API;
using cAlgo.API.Indicators;

namespace cAlgo
{
    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.None)]
    public class EntryFramework_001_004 : Robot
    {
        // ============================================================
        // CODE NAME (Project Constitution compliant)
        // ============================================================
        // BASE: ENTRY_FRAMEWORK_M5_ALL_001_000_001_B
        // THIS: ENTRY_FRAMEWORK_M5_ALL_001_004
        private const string CODE_NAME = "ENTRY_FRAMEWORK_M5_ALL_001_004";
        private const string BOT_LABEL = "ENTRY_FRAMEWORK_M5_ALL_001_004";
        // ============================================================

        // ================= PARAMETERS =================

        // ===== 資金管理・ロット制御 =====

        [Parameter("１トレードのリスク額", Group = "資金管理・ロット制御", DefaultValue = 1000.0, MinValue = 0.0)]
        public double RiskDollars { get; set; }

        [Parameter("リスク計算バッファ（PIPS）", Group = "資金管理・ロット制御", DefaultValue = 50.0, MinValue = 0.0)]
        public double RiskBufferPips { get; set; }

        [Parameter("緊急クローズ倍率", Group = "資金管理・ロット制御", DefaultValue = 1.2, MinValue = 1.0)]
        public double EmergencyCloseMult { get; set; }

        [Parameter("最大ポジション数", Group = "資金管理・ロット制御", DefaultValue = 1, MinValue = 1)]
        public int MaxPositions { get; set; }

        [Parameter("最大ロット数（0=無制限）", Group = "資金管理・ロット制御", DefaultValue = 2.5, MinValue = 0.0)]
        public double MaxLotsCap { get; set; }

        [Parameter("建値移動トリガー", Group = "資金管理・ロット制御", DefaultValue = 1000.0, MinValue = 0.0)]
        public double BreakevenTriggerDollars { get; set; }

        // ===== ストップロス関連 =====

        [Parameter("最小SL（PIPS）", Group = "ストップロス関連", DefaultValue = 20.0, MinValue = 0.0)]
        public double MinSLPips { get; set; }

        [Parameter("最小SL用ATR期間", Group = "ストップロス関連", DefaultValue = 14, MinValue = 1)]
        public int MinSlAtrPeriod { get; set; }

        [Parameter("最小SL用ATR倍率", Group = "ストップロス関連", DefaultValue = 0.5, MinValue = 0.0)]
        public double MinSlAtrMult { get; set; }

        // ===== 利確（TP）関連 =====

        [Parameter("最小TP距離（PIPS）", Group = "利確（TP）関連", DefaultValue = 0.0, MinValue = 0.0)]
        public double MinTpDistancePips { get; set; }

        [Parameter("最低RR（1未満は1に丸め）", Group = "利確（TP）関連", DefaultValue = 1.0, MinValue = 0.0)]
        public double MinRRRatio { get; set; }


        // ===== エントリー距離・再接近制御 =====

        [Parameter("エントリー最大距離（PIPS）", Group = "エントリー距離・再接近制御", DefaultValue = 50.0, MinValue = 0.0)]
        public double EntryMaxDistancePips { get; set; }

        [Parameter("再接近監視バー数", Group = "エントリー距離・再接近制御", DefaultValue = 36, MinValue = 1)]
        public int ReapproachWindowBars { get; set; }

        [Parameter("再接近最大距離（PIPS）", Group = "エントリー距離・再接近制御", DefaultValue = 40.0, MinValue = 0.0)]
        public double ReapproachMaxDistancePips { get; set; }

        // ===== 新Entry（EMA） =====

        [Parameter("EMA期間", Group = "新Entry（EMA）", DefaultValue = 20, MinValue = 1)]
        public int EmaPeriod { get; set; }
        [Parameter("EMA判定ログ出力（はい・いいえ）", Group = "新Entry（EMA）", DefaultValue = false)]
        public bool EnableEmaDecisionLog { get; set; }
        // MODIFY(017_005): DefaultValue 20.0 -> 10.0

        // ADD(017_005): Hysteresis ratio parameter (Exit/Enter)

        // ADD(017_006): Minimum hold bars after direction state change

        // ADD(017_007): PP line-specific direction control (apply/disable + min hold override)

        // ===== Trading Window (JST) =====  (UI規律: 最下段)

        [Parameter("取引時間制御を有効にする（はい・いいえ）", Group = "取引時間帯（JST）", DefaultValue = true)]
        public bool EnableTradingWindowFilter { get; set; }

        [Parameter("取引開始（JST）", Group = "取引時間帯（JST）", DefaultValue = "09:15")]
        public string TradeStartTimeJst { get; set; }

        [Parameter("取引終了（JST）", Group = "取引時間帯（JST）", DefaultValue = "02:00")]
        public string TradeEndTimeJst { get; set; }

        [Parameter("強制フラット（JST）", Group = "取引時間帯（JST）", DefaultValue = "02:50")]
        public string ForceFlatTimeJst { get; set; }
        // ================= STATE =================

        private AverageTrueRange _atrMinSl;
        private ExponentialMovingAverage _emaSignal;
        private TimeZoneInfo _jstTz;
        private TimeZoneInfo _nyTz;

        // Emergency close: per-position latch (avoid multi-close storms)
        private readonly HashSet<long> _emergencyCloseRequested = new HashSet<long>();

        private enum TradingWindowState { AllowNewEntries = 0, HoldOnly = 1, ForceFlat = 2 }

        // --- Trading window minutes (JST) resolved from string params ---
        private int _tradeStartMinJst = 0;
        private int _tradeEndMinJst = 0;
        private int _forceFlatMinJst = 0;

        // ============================================================
        // Phase2: Entry meta (MinHold gate support) + MFE/MAE
        // ============================================================

        private sealed class MfeMae
        {
            public double MfeDollars;
            public double MaeDollars;
        }
        private readonly Dictionary<long, MfeMae> _mfeMaeByPosId = new Dictionary<long, MfeMae>();

        protected override void OnStart()
        {
            // Timezones (best-effort)
            _jstTz = ResolveTokyoTimeZone();
            _nyTz = ResolveNewYorkTimeZone();

            // Trading window parsing
            ResolveTradingWindowMinutesOrDefaults();

            // Indicators
            _atrMinSl = Indicators.AverageTrueRange(MinSlAtrPeriod, MovingAverageType.Exponential);
            _emaSignal = Indicators.ExponentialMovingAverage(Bars.ClosePrices, EmaPeriod);        }

        protected override void OnBar()
        {
            if (Bars.Count < 50)
                return;

            DateTime utcNow = Server.Time;

            if (EnableTradingWindowFilter)
            {
                DateTime jstNow = ToJst(utcNow);
                TradingWindowState state = GetTradingWindowState(jstNow);

                if (state == TradingWindowState.ForceFlat)
                {
                    if (EnableEmaDecisionLog)
                    {
                        Print("BLOCK_E00_TIMEWINDOW | CodeName={0} | Symbol={1} | Reason=ForceFlat | UtcNow={2:o} | JstNow={3:yyyy-MM-dd HH:mm:ss} | Window={4}-{5} | ForceFlat={6}",
                            CODE_NAME, SymbolName, DateTime.SpecifyKind(utcNow, DateTimeKind.Utc), jstNow, TradeStartTimeJst, TradeEndTimeJst, ForceFlatTimeJst);
                    }
                    return;
                }

                if (state != TradingWindowState.AllowNewEntries)
                {
                    if (EnableEmaDecisionLog)
                    {
                        Print("BLOCK_E00_TIMEWINDOW | CodeName={0} | Symbol={1} | Reason=HoldOnly | UtcNow={2:o} | JstNow={3:yyyy-MM-dd HH:mm:ss} | Window={4}-{5} | ForceFlat={6}",
                            CODE_NAME, SymbolName, DateTime.SpecifyKind(utcNow, DateTimeKind.Utc), jstNow, TradeStartTimeJst, TradeEndTimeJst, ForceFlatTimeJst);
                    }
                    return;
                }
            }

            if (Positions.Count >= MaxPositions)
            {
                if (EnableEmaDecisionLog)
                {
                    Print("BLOCK_E01_MAXPOS | CodeName={0} | Symbol={1} | UtcNow={2:o} | Positions={3} >= MaxPositions={4}",
                        CODE_NAME, SymbolName, DateTime.SpecifyKind(utcNow, DateTimeKind.Utc), Positions.Count, MaxPositions);
                }
                return;
            }

            TryEmaEntry();
        }

        // ================= OnTimer (ForceClose supervisor) =================

        protected override void OnTimer()
        {
            if (!EnableTradingWindowFilter)
                return;

            DateTime utcNow = Server.Time;
            DateTime jstNow = ToJst(utcNow);

            TradingWindowState state = GetTradingWindowState(jstNow);

            if (state == TradingWindowState.ForceFlat)
            {
                if (!HasOpenPositionsOnThisSymbol())
                    return;

                CloseAllPositionsOnThisSymbol("FORCE_CLOSE_WINDOW(JST)");
            }
        }

        private bool HasOpenPositionsOnThisSymbol()
        {
            for (int i = Positions.Count - 1; i >= 0; i--)
            {
                Position p = Positions[i];
                if (p == null) continue;
                if (p.SymbolName != SymbolName) continue;
                return true;
            }
            return false;
        }

        // ================= EMERGENCY CLOSE =================

        private void ApplyEmergencyCloseIfNeeded()
        {
            double risk = Math.Max(0.0, RiskDollars);
            if (risk <= 0.0)
                return;

            double mult = Math.Max(1.0, EmergencyCloseMult);
            double threshold = -risk * mult;

            for (int i = Positions.Count - 1; i >= 0; i--)
            {
                Position p = Positions[i];
                if (p == null) continue;
                if (p.SymbolName != SymbolName) continue;

                if (_emergencyCloseRequested.Contains(p.Id))
                    continue;

                if (p.NetProfit <= threshold)
                {
                    _emergencyCloseRequested.Add(p.Id);

                    var res = ClosePosition(p);

                    Print(
                        "EMERGENCY_CLOSE | CodeName={0} | PosId={1} | NetProfit={2} <= Thr={3}",
                        CODE_NAME,
                        p.Id,
                        p.NetProfit.ToString("F2", CultureInfo.InvariantCulture),
                        threshold.ToString("F2", CultureInfo.InvariantCulture)
                    );

                    if (res == null || !res.IsSuccessful)
                        _emergencyCloseRequested.Remove(p.Id);
                }
            }
        }

        // ================= BREAKEVEN =================

        private void ApplyBreakevenMoveIfNeeded()
        {
            double trigger = Math.Max(0.0, BreakevenTriggerDollars);
            if (trigger <= 0.0)
                return;

            for (int i = Positions.Count - 1; i >= 0; i--)
            {
                Position p = Positions[i];
                if (p == null) continue;
                if (p.SymbolName != SymbolName) continue;
                if (p.NetProfit < trigger) continue;

                double entry = p.EntryPrice;

                if (p.TradeType == TradeType.Buy)
                {
                    if (p.StopLoss.HasValue && p.StopLoss.Value >= entry)
                        continue;

                    ModifyPosition(p, entry, p.TakeProfit, ProtectionType.Absolute);
                }
                else
                {
                    if (p.StopLoss.HasValue && p.StopLoss.Value <= entry)
                        continue;

                    ModifyPosition(p, entry, p.TakeProfit, ProtectionType.Absolute);
                }
            }
        }

        // ================= PIVOT (Classic Extended) =================

        private void TryEmaEntry()
        {
            // Use closed bars for signal to avoid intra-bar noise
            if (Bars.Count < 3)
                return;

            if (!SymbolInfoTick(out double bid, out double ask))
                return;

            double close1 = Bars.ClosePrices.Last(1);
            double close2 = Bars.ClosePrices.Last(2);

            double ema1 = (_emaSignal != null && _emaSignal.Result != null && _emaSignal.Result.Count > 0) ? _emaSignal.Result.Last(1) : 0.0;
            double ema2 = (_emaSignal != null && _emaSignal.Result != null && _emaSignal.Result.Count > 0) ? _emaSignal.Result.Last(2) : 0.0;

            if (ema1 == 0.0 || ema2 == 0.0)
                return;

            bool crossUp = (close2 <= ema2) && (close1 > ema1);
            bool crossDown = (close2 >= ema2) && (close1 < ema1);

            if (!crossUp && !crossDown)
                return;

            TradeType type;
            if (crossUp)
                type = TradeType.Buy;
            else
                type = TradeType.Sell;

double entry = (type == TradeType.Buy) ? ask : bid;
            double spreadPrice = ask - bid;
            double spreadPips = spreadPrice / Symbol.PipSize;

            if (EnableEmaDecisionLog)
            {
                Print(
                    "EMA_SIGNAL | CodeName={0} | Symbol={1} | UtcNow={2:o} | Cross={3} | Type={4} | Close2={5} EMA2={6} | Close1={7} EMA1={8} | Entry={9} | Bid={10} Ask={11} | SpreadPips={12:F2}",
                    CODE_NAME,
                    SymbolName,
                    DateTime.SpecifyKind(Server.Time, DateTimeKind.Utc),
                    crossUp ? "UP" : "DOWN",
                    type.ToString(),
                    close2.ToString("G17", CultureInfo.InvariantCulture),
                    ema2.ToString("G17", CultureInfo.InvariantCulture),
                    close1.ToString("G17", CultureInfo.InvariantCulture),
                    ema1.ToString("G17", CultureInfo.InvariantCulture),
                    entry.ToString("G17", CultureInfo.InvariantCulture),
                    bid.ToString("G17", CultureInfo.InvariantCulture),
                    ask.ToString("G17", CultureInfo.InvariantCulture),
                     spreadPips
                 );
            }


            // Minimal SL/TP construction: use the same minimum SL guard basis as PlaceTrade
            double minSlPipsFromPips = Math.Max(0.0, MinSLPips) * 10.0;
            double minSlPriceFromPips = minSlPipsFromPips * Symbol.PipSize;

            double atrValue = (_atrMinSl != null && _atrMinSl.Result != null && _atrMinSl.Result.Count > 0)
                ? _atrMinSl.Result.LastValue
                : 0.0;

            double minSlPriceFromAtr = Math.Max(0.0, MinSlAtrMult) * atrValue;
            double slDistancePrice = Math.Max(minSlPriceFromPips, minSlPriceFromAtr);

            if (slDistancePrice <= 0.0)
            {
                if (EnableEmaDecisionLog)
                {
                    Print("BLOCK_E10_SLDIST0 | CodeName={0} | Symbol={1} | Reason=ComputedSlDistancePrice<=0 | Entry={2} | MinSlPriceFromPips={3} | MinSlPriceFromAtr={4} | AtrValue={5}",
                        CODE_NAME,
                        SymbolName,
                        entry.ToString("G17", CultureInfo.InvariantCulture),
                        minSlPriceFromPips.ToString("G17", CultureInfo.InvariantCulture),
                        minSlPriceFromAtr.ToString("G17", CultureInfo.InvariantCulture),
                        atrValue.ToString("G17", CultureInfo.InvariantCulture)
                    );
                }
                return;
            }

            double stop = (type == TradeType.Buy) ? (entry - slDistancePrice) : (entry + slDistancePrice);

            double rr = Math.Max(1.0, MinRRRatio);
            double tpTargetPrice = (type == TradeType.Buy) ? (entry + slDistancePrice * rr) : (entry - slDistancePrice * rr);

            if (EnableEmaDecisionLog)
            {
                Print(
                    "EMA_PACKET | CodeName={0} | Symbol={1} | UtcNow={2:o} | Cross={3} | Type={4} | Entry={5} | Stop={6} | TpTarget={7} | RR(Used)={8} | SL_Price={9} | SL_MinPipsPrice={10} | SL_ATRPrice={11} | ATR={12} | MinRRParam={13}",
                    CODE_NAME,
                    SymbolName,
                    DateTime.SpecifyKind(Server.Time, DateTimeKind.Utc),
                    crossUp ? "UP" : "DOWN",
                    type.ToString(),
                    entry.ToString("G17", CultureInfo.InvariantCulture),
                    stop.ToString("G17", CultureInfo.InvariantCulture),
                    tpTargetPrice.ToString("G17", CultureInfo.InvariantCulture),
                    rr.ToString("G17", CultureInfo.InvariantCulture),
                    slDistancePrice.ToString("G17", CultureInfo.InvariantCulture),
                    minSlPriceFromPips.ToString("G17", CultureInfo.InvariantCulture),
                    minSlPriceFromAtr.ToString("G17", CultureInfo.InvariantCulture),
                    atrValue.ToString("G17", CultureInfo.InvariantCulture),
                    Math.Max(0.0, MinRRRatio).ToString("G17", CultureInfo.InvariantCulture)
                );
            }

            PlaceTrade(type, entry, stop, tpTargetPrice, crossUp ? "EMA_CROSS_UP" : "EMA_CROSS_DOWN");
        }

        
private void PlaceTrade(TradeType type, double entry, double stop, double tpTargetPrice, string reasonTag)
        {
            bool emaLog = EnableEmaDecisionLog && !string.IsNullOrWhiteSpace(reasonTag) && reasonTag.StartsWith("EMA_", StringComparison.OrdinalIgnoreCase);

            double riskDollars = Math.Max(0.0, RiskDollars);
            if (riskDollars <= 0.0)
            {
                if (emaLog)
                    Print("BLOCK_E02_RISK0 | CodeName={0} | Symbol={1} | RiskDollars={2} | ReasonTag={3}", CODE_NAME, SymbolName, riskDollars.ToString("G17", CultureInfo.InvariantCulture), reasonTag);
                return;
            }

            if (Account.Balance <= 0)
            {
                if (emaLog)
                    Print("BLOCK_E03_BALANCE0 | CodeName={0} | Symbol={1} | Balance={2} | ReasonTag={3}", CODE_NAME, SymbolName, Account.Balance.ToString("G17", CultureInfo.InvariantCulture), reasonTag);
                return;
            }

            double slDistancePrice = Math.Abs(entry - stop);
            if (slDistancePrice <= 0.0)
            {
                if (emaLog)
                    Print("BLOCK_E04_SLDIST0 | CodeName={0} | Symbol={1} | Entry={2} | Stop={3} | ReasonTag={4}", CODE_NAME, SymbolName, entry.ToString("G17", CultureInfo.InvariantCulture), stop.ToString("G17", CultureInfo.InvariantCulture), reasonTag);
                return;
            }

            double slPips = slDistancePrice / Symbol.PipSize;
            if (slPips <= 0.0)
            {
                if (emaLog)
                    Print("BLOCK_E05_SLPIPS0 | CodeName={0} | Symbol={1} | SlPips={2} | PipSize={3} | ReasonTag={4}", CODE_NAME, SymbolName, slPips.ToString("G17", CultureInfo.InvariantCulture), Symbol.PipSize.ToString("G17", CultureInfo.InvariantCulture), reasonTag);
                return;
            }

            double minSlPipsFromPips = Math.Max(0.0, MinSLPips) * 10.0;
            double minSlPriceFromPips = minSlPipsFromPips * Symbol.PipSize;

            double atrValue = (_atrMinSl != null && _atrMinSl.Result != null && _atrMinSl.Result.Count > 0)
                ? _atrMinSl.Result.LastValue
                : 0.0;

            double minSlPriceFromAtr = Math.Max(0.0, MinSlAtrMult) * atrValue;
            double minSlPriceFinal = Math.Max(minSlPriceFromPips, minSlPriceFromAtr);

            if (minSlPriceFinal > 0.0 && slDistancePrice < minSlPriceFinal)
            {
                if (emaLog)
                    Print("BLOCK_E06_MINSL_FAIL | CodeName={0} | Symbol={1} | SlDistancePrice={2} < MinSlPriceFinal={3} | MinSlFromPips={4} | MinSlFromAtr={5} | ATR={6} | ReasonTag={7}",
                        CODE_NAME,
                        SymbolName,
                        slDistancePrice.ToString("G17", CultureInfo.InvariantCulture),
                        minSlPriceFinal.ToString("G17", CultureInfo.InvariantCulture),
                        minSlPriceFromPips.ToString("G17", CultureInfo.InvariantCulture),
                        minSlPriceFromAtr.ToString("G17", CultureInfo.InvariantCulture),
                        atrValue.ToString("G17", CultureInfo.InvariantCulture),
                        reasonTag);
                return;
            }

            double bufferPipsInternal = Math.Max(0.0, RiskBufferPips) * 10.0;
            double sizingPips = slPips + bufferPipsInternal;
            if (sizingPips <= 0.0)
            {
                if (emaLog)
                    Print("BLOCK_E07_SIZINGPIPS0 | CodeName={0} | Symbol={1} | SlPips={2} | BufferPips={3} | SizingPips={4} | ReasonTag={5}",
                        CODE_NAME,
                        SymbolName,
                        slPips.ToString("G17", CultureInfo.InvariantCulture),
                        bufferPipsInternal.ToString("G17", CultureInfo.InvariantCulture),
                        sizingPips.ToString("G17", CultureInfo.InvariantCulture),
                        reasonTag);
                return;
            }

            double volumeUnitsRaw = riskDollars / (sizingPips * Symbol.PipValue);

            long volumeInUnits = (long)Symbol.NormalizeVolumeInUnits(volumeUnitsRaw, RoundingMode.Down);
            if (volumeInUnits < Symbol.VolumeInUnitsMin)
            {
                if (emaLog)
                    Print("BLOCK_E08_LOT_TOO_SMALL | CodeName={0} | Symbol={1} | VolumeUnitsRaw={2} | VolumeUnitsNorm={3} < Min={4} | SlPips={5} | BufferPips={6} | PipValue={7} | ReasonTag={8}",
                        CODE_NAME,
                        SymbolName,
                        volumeUnitsRaw.ToString("G17", CultureInfo.InvariantCulture),
                        volumeInUnits,
                        Symbol.VolumeInUnitsMin,
                        slPips.ToString("G17", CultureInfo.InvariantCulture),
                        bufferPipsInternal.ToString("G17", CultureInfo.InvariantCulture),
                        Symbol.PipValue.ToString("G17", CultureInfo.InvariantCulture),
                        reasonTag);
                return;
            }

            if (MaxLotsCap > 0.0)
            {
                long maxUnits = (long)Symbol.NormalizeVolumeInUnits(Symbol.QuantityToVolumeInUnits(MaxLotsCap), RoundingMode.Down);
                if (maxUnits > 0 && volumeInUnits > maxUnits)
                    volumeInUnits = maxUnits;
            }

            double tpPipsFromTarget = 0.0;
            bool targetValid = false;

            if (type == TradeType.Buy && tpTargetPrice > entry)
            {
                tpPipsFromTarget = (tpTargetPrice - entry) / Symbol.PipSize;
                targetValid = tpPipsFromTarget > 0;
            }
            else if (type == TradeType.Sell && tpTargetPrice < entry)
            {
                tpPipsFromTarget = (entry - tpTargetPrice) / Symbol.PipSize;
                targetValid = tpPipsFromTarget > 0;
            }

            if (!targetValid)
            {
                Print(
                    "SKIP_TP_TARGET_INVALID | CodeName={0} | Symbol={1} | TradeType={2} | Entry={3} | TpTarget={4} | ReasonTag={5} | Reason=TP_NOT_FORWARD",
                    CODE_NAME,
                    SymbolName,
                    type,
                    entry.ToString("F2", CultureInfo.InvariantCulture),
                    tpTargetPrice.ToString("F2", CultureInfo.InvariantCulture),
                    string.IsNullOrWhiteSpace(reasonTag) ? "NA" : reasonTag
                );
                return;
            }

            double minTpInternalPips = Math.Max(0.0, MinTpDistancePips) * 10.0;
            if (minTpInternalPips > 0.0 && tpPipsFromTarget < minTpInternalPips)
            {
                Print(
                    "SKIP_TP_TOO_CLOSE | CodeName={0} | Symbol={1} | TradeType={2} | Entry={3} | TpTarget={4} | TpPips={5} | MinTpPips={6} | PipSize={7} | ReasonTag={8}",
                    CODE_NAME,
                    SymbolName,
                    type,
                    entry.ToString("F2", CultureInfo.InvariantCulture),
                    tpTargetPrice.ToString("F2", CultureInfo.InvariantCulture),
                    tpPipsFromTarget.ToString("F1", CultureInfo.InvariantCulture),
                    minTpInternalPips.ToString("F1", CultureInfo.InvariantCulture),
                    Symbol.PipSize.ToString("G17", CultureInfo.InvariantCulture),
                    string.IsNullOrWhiteSpace(reasonTag) ? "NA" : reasonTag
                );
                return;
            }
            TradeResult result = ExecuteMarketOrder(
                type,
                SymbolName,
                volumeInUnits,
                BOT_LABEL,
                slPips,
                tpPipsFromTarget
            );

            if (result == null || !result.IsSuccessful || result.Position == null)
            {
                if (emaLog)
                {
                    string err = result == null ? "ResultNull" : result.Error.ToString();
                    Print("BLOCK_E09_EXEC_FAIL | CodeName={0} | Symbol={1} | TradeType={2} | Entry={3} | SlPips={4} | TpPips={5} | Error={6} | ReasonTag={7}",
                        CODE_NAME,
                        SymbolName,
                        type.ToString(),
                        entry.ToString("G17", CultureInfo.InvariantCulture),
                        slPips.ToString("G17", CultureInfo.InvariantCulture),
                        tpPipsFromTarget.ToString("G17", CultureInfo.InvariantCulture),
                        err,
                        reasonTag);
                }
                return;
            }

            _emergencyCloseRequested.Remove(result.Position.Id);

            long posId = result.Position.Id;
            if (!_mfeMaeByPosId.ContainsKey(posId))
                _mfeMaeByPosId[posId] = new MfeMae { MfeDollars = 0.0, MaeDollars = 0.0 };
        }

        private void UpdateMfeMaeForOpenPositions()
        {
            if (!SymbolInfoTick(out double bid, out double ask))
                return;

            for (int i = Positions.Count - 1; i >= 0; i--)
            {
                Position p = Positions[i];
                if (p == null) continue;
                if (p.SymbolName != SymbolName) continue;

                long id = p.Id;

                if (!_mfeMaeByPosId.TryGetValue(id, out MfeMae mm))
                {
                    mm = new MfeMae { MfeDollars = 0.0, MaeDollars = 0.0 };
                    _mfeMaeByPosId[id] = mm;
                }

                double lots = Symbol.VolumeInUnitsToQuantity(p.VolumeInUnits);

                double unrealDollars;
                if (p.TradeType == TradeType.Buy)
                {
                    double pips = (bid - p.EntryPrice) / Symbol.PipSize;
                    unrealDollars = pips * Symbol.PipValue * lots;
                }
                else
                {
                    double pips = (p.EntryPrice - ask) / Symbol.PipSize;
                    unrealDollars = pips * Symbol.PipValue * lots;
                }

                double mfeCandidate = Math.Max(0.0, unrealDollars);
                double maeCandidate = Math.Max(0.0, -unrealDollars);

                if (mfeCandidate > mm.MfeDollars) mm.MfeDollars = mfeCandidate;
                if (maeCandidate > mm.MaeDollars) mm.MaeDollars = maeCandidate;
            }
        }

        private void OnPositionClosed(PositionClosedEventArgs args)
        {
            if (args == null || args.Position == null)
                return;

            Position p = args.Position;
            if (p.SymbolName != SymbolName)
                return;

            long posId = p.Id;

            // Cleanup: tracked caches for this position (if any)
            if (_mfeMaeByPosId.ContainsKey(posId))
                _mfeMaeByPosId.Remove(posId);

            if (_emergencyCloseRequested.Contains(posId))
                _emergencyCloseRequested.Remove(posId);
        }


        private void CloseAllPositionsOnThisSymbol(string reason)
        {
            int closeRequested = 0;

            for (int i = Positions.Count - 1; i >= 0; i--)
            {
                Position p = Positions[i];
                if (p == null) continue;
                if (p.SymbolName != SymbolName) continue;

                ClosePosition(p);
                closeRequested++;
            }

            if (closeRequested > 0)
            {
                Print(
                    "FORCE CLOSE | CodeName={0} | Symbol={1} | Reason={2} | CloseRequested={3}",
                    CODE_NAME,
                    SymbolName,
                    reason,
                    closeRequested
                );
            }
        }

        private TradingWindowState GetTradingWindowState(DateTime jstNow)
        {
            int nowMin = jstNow.Hour * 60 + jstNow.Minute;

            int startMin = _tradeStartMinJst;
            int endMin = _tradeEndMinJst;
            int forceMin = _forceFlatMinJst;

            if (IsInRangeCircular(nowMin, startMin, endMin))
                return TradingWindowState.AllowNewEntries;

            if (IsInRangeCircular(nowMin, endMin, forceMin))
                return TradingWindowState.HoldOnly;

            return TradingWindowState.ForceFlat;
        }

        private bool IsInRangeCircular(int nowMin, int startMin, int endMin)
        {
            if (startMin == endMin) return false;

            if (startMin < endMin)
                return nowMin >= startMin && nowMin < endMin;

            return nowMin >= startMin || nowMin < endMin;
        }

        private void ResolveTradingWindowMinutesOrDefaults()
        {
            const string DEF_START = "09:15";
            const string DEF_END = "02:00";
            const string DEF_FORCE = "02:50";

            string startText = string.IsNullOrWhiteSpace(TradeStartTimeJst) ? DEF_START : TradeStartTimeJst.Trim();
            string endText = string.IsNullOrWhiteSpace(TradeEndTimeJst) ? DEF_END : TradeEndTimeJst.Trim();
            string forceText = string.IsNullOrWhiteSpace(ForceFlatTimeJst) ? DEF_FORCE : ForceFlatTimeJst.Trim();

            bool okStart = TryParseHmToMinutes(startText, out int startMin);
            bool okEnd = TryParseHmToMinutes(endText, out int endMin);
            bool okForce = TryParseHmToMinutes(forceText, out int forceMin);

            if (!okStart)
            {
                Print("TIME_PARSE_FAIL | CodeName={0} | Field=TradeStartTimeJst | Text={1} | Fallback={2}", CODE_NAME, startText, DEF_START);
                TryParseHmToMinutes(DEF_START, out startMin);
            }

            if (!okEnd)
            {
                Print("TIME_PARSE_FAIL | CodeName={0} | Field=TradeEndTimeJst | Text={1} | Fallback={2}", CODE_NAME, endText, DEF_END);
                TryParseHmToMinutes(DEF_END, out endMin);
            }

            if (!okForce)
            {
                Print("TIME_PARSE_FAIL | CodeName={0} | Field=ForceFlatTimeJst | Text={1} | Fallback={2}", CODE_NAME, forceText, DEF_FORCE);
                TryParseHmToMinutes(DEF_FORCE, out forceMin);
            }

            _tradeStartMinJst = startMin;
            _tradeEndMinJst = endMin;
            _forceFlatMinJst = forceMin;
        }

        private bool TryParseHmToMinutes(string text, out int minutes)
        {
            minutes = 0;
            if (string.IsNullOrWhiteSpace(text))
                return false;

            string t = text.Trim();
            string[] parts = t.Split(':');
            if (parts.Length != 2)
                return false;

            if (!int.TryParse(parts[0], NumberStyles.Integer, CultureInfo.InvariantCulture, out int h))
                return false;
            if (!int.TryParse(parts[1], NumberStyles.Integer, CultureInfo.InvariantCulture, out int m))
                return false;

            if (h < 0 || h > 23) return false;
            if (m < 0 || m > 59) return false;

            minutes = h * 60 + m;
            return true;
        }

        private DateTime ToJst(DateTime utcNow)
        {
            DateTime utc = DateTime.SpecifyKind(utcNow, DateTimeKind.Utc);
            return _jstTz == null ? utc : TimeZoneInfo.ConvertTimeFromUtc(utc, _jstTz);
        }

        private TimeZoneInfo ResolveTokyoTimeZone()
        {
            string[] candidateIds = new[] { "Tokyo Standard Time", "Asia/Tokyo" };
            foreach (string id in candidateIds)
            {
                try { return TimeZoneInfo.FindSystemTimeZoneById(id); } catch { }
            }
            return TimeZoneInfo.Utc;
        }

        private TimeZoneInfo ResolveNewYorkTimeZone()
        {
            string[] candidateIds = new[] { "Eastern Standard Time", "America/New_York" };
            foreach (string id in candidateIds)
            {
                try { return TimeZoneInfo.FindSystemTimeZoneById(id); } catch { }
            }
            return null;
        }


        // ================= PRICE =================
        // 規律: 価格取得は必ず SymbolInfoTick を使用すること

        private bool SymbolInfoTick(out double bid, out double ask)
        {
            bid = 0.0;
            ask = 0.0;

            try
            {
                bid = Symbol.Bid;
                ask = Symbol.Ask;
                return bid > 0.0 && ask > 0.0;
            }
            catch
            {
                return false;
            }
        }
    }
}